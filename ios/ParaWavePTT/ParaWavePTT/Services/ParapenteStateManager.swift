import Foundation
import SwiftUI

/*
 Copyright (C) 2025 Ronan Le Meillat
 SPDX-License-Identifier: AGPL-3.0-or-later

 This file is part of ParaWave PTT.
 ParaWave PTT is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 ParaWave PTT is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License
 along with this program. If not, see <https://www.gnu.org/licenses/agpl-3.0.en.html>.
*/

// Main application state manager for ParaWave PTT
@MainActor
class ParapenteStateManager: ObservableObject {

  // MARK: - Published Properties

  @Published var currentState: ParapenteAppState = .launching
  @Published var showError = false
  @Published var errorMessage = ""

  // MARK: - Dependencies

  private var networkService: ParapenteNetworkService?
  private var pttChannelManager: PTTChannelManager?
  private var audioManager: PTTAudioManager?
  private let keychainManager = Auth0KeychainManager()

  // MARK: - Initialization

  init() {
    setupNotificationObservers()
  }

  private func setupNotificationObservers() {
    NotificationCenter.default.addObserver(
      self,
      selector: #selector(handleAuthenticationStateChanged),
      name: .auth0AuthenticationStateChanged,
      object: nil
    )

    NotificationCenter.default.addObserver(
      self,
      selector: #selector(handleTokenWillExpire),
      name: .auth0TokenWillExpire,
      object: nil
    )
  }

  // MARK: - Public Methods

  /// Initialize the app with required services
  func initialize(networkService: ParapenteNetworkService) async {
    self.networkService = networkService

    // Check authentication state at startup
    await checkAuthenticationState()
  }

  /// Check authentication state and transition to the appropriate app state
  private func checkAuthenticationState() async {
    let authStatus = keychainManager.getAuthenticationStatus()

    switch authStatus {
    case .authenticated(_, let userId, let permissions):
      print("User already authenticated: \(userId)")
      transition(to: .authenticated(permissions: permissions))
      await loadAvailableChannels()

    case .unauthenticated:
      print("Authentication required")
      transition(to: .authentication)

    case .error(let error):
      print("Authentication error: \(error)")
      transition(to: .authentication)
    }
  }

  // MARK: - Authentication Methods

  /// Start the Auth0 authentication process
  func authenticateWithAuth0() async {
    transition(to: .authentication)

    do {
      // Here you would integrate the Auth0 SDK for iOS
      // For this implementation we simulate a successful authentication

      // TODO: Integrate Auth0 SDK
      // let credentials = try await Auth0.webAuth().start()
      // let userInfo = try await Auth0.users().userInfo(withAccessToken: credentials.accessToken)

      // Simulation for development
      let simulatedToken = "simulated_access_token"
      let simulatedUserId = "auth0|simulated_user_id"
      let simulatedPermissions = [
        "read:api", "access:chamonix-local-001", "access:annecy-local-001",
      ]

      // Store authentication information
      let tokenInfo = Auth0KeychainManager.Auth0TokenInfo(
        accessToken: simulatedToken,
        refreshToken: "simulated_refresh_token",
        expiresIn: 3600,  // 1 hour
        userId: simulatedUserId,
        permissions: simulatedPermissions
      )

      try keychainManager.updateTokenInfo(tokenInfo)

      print("Authentication succeeded for: \(simulatedUserId)")
      transition(to: .authenticated(permissions: simulatedPermissions))

      // Load available channels
      await loadAvailableChannels()

    } catch {
      print("Authentication error: \(error)")
      transition(to: .error(.authenticationFailed(error)))
    }
  }

  /// Log out and clean up data
  func logout() async {
    do {
      // Clear keychain
      try keychainManager.deleteAllTokens()

      // Stop all services
      await cleanupServices()

      print("Logout successful")
      transition(to: .authentication)

    } catch {
      print("Error during logout: \(error)")
      showErrorMessage("Error during logout: \(error.localizedDescription)")
    }
  }

  // MARK: - Channel Management

  /// Load available channels for the user
  private func loadAvailableChannels() async {
    guard let networkService = networkService else {
      transition(
        to: .error(.networkError(NSError(domain: "NoNetworkService", code: 0, userInfo: nil))))
      return
    }

    do {
      let channels = try await networkService.getChannels()
      print("Loaded \(channels.count) available channels")

      // Move to channel selection if channels are available
      if !channels.isEmpty {
        transition(to: .channelSelection)
      }

    } catch {
      print("Error loading channels: \(error)")
      transition(to: .error(.networkError(error)))
    }
  }

  /// Join a PTT channel
  func joinChannel(_ channel: PTTChannel) async {
    guard let networkService = networkService else {
      showErrorMessage("Network service not available")
      return
    }

    do {
      // Create the PTT manager if it doesn't exist
      if pttChannelManager == nil {
        pttChannelManager = PTTChannelManager(networkService: networkService)
      }

      // Create the audio manager if it doesn't exist
      if audioManager == nil {
        audioManager = PTTAudioManager(pttChannelManager: pttChannelManager)
      }

      // Join the channel
      try await pttChannelManager?.joinChannel(channel)

      print("Channel joined successfully: \(channel.name)")
      transition(to: .channelJoined(channel: channel))

    } catch {
      print("Error joining channel: \(error)")
      showErrorMessage("Unable to join channel: \(error.localizedDescription)")
    }
  }

  /// Leave the current channel
  func leaveCurrentChannel() async {
    do {
      try await pttChannelManager?.leaveCurrentChannel()
      print("Channel left successfully")

      // Return to channel selection
      await loadAvailableChannels()

    } catch {
      print("Error leaving channel: \(error)")
      showErrorMessage("Error leaving channel: \(error.localizedDescription)")
    }
  }

  // MARK: - PTT Transmission

  /// Start a PTT transmission
  func startTransmission() async {
    guard let audioManager = audioManager else {
      showErrorMessage("Audio manager not available")
      return
    }

    do {
      // Check microphone permissions
      guard await PTTAudioManager.requestMicrophonePermission() else {
        showErrorMessage("Microphone permission required for PTT transmissions")
        return
      }

      // Start recording
      try await audioManager.startRecording()

      print("PTT transmission started")

      if case .channelJoined(_) = currentState {
        transition(to: .activeTransmission(sessionId: "active_transmission"))
      }

    } catch {
      print("Error starting transmission: \(error)")
      showErrorMessage("Unable to start transmission: \(error.localizedDescription)")
    }
  }

  /// Stop the PTT transmission
  func stopTransmission() async {
    guard let audioManager = audioManager else {
      return
    }

    await audioManager.stopRecording()
    print("PTT transmission stopped")

    // Return to joined channel state
    if let pttChannelManager = pttChannelManager,
      let currentChannel = await getCurrentChannel(from: pttChannelManager)
    {
      transition(to: .channelJoined(channel: currentChannel))
    }
  }

  // MARK: - Emergency Functions

  /// Join the emergency channel
  func joinEmergencyChannel() async {
    guard let networkService = networkService else {
      showErrorMessage("Network service not available")
      return
    }

    do {
      // Search for an emergency channel
      let channels = try await networkService.getChannels(type: .emergency)

      if let emergencyChannel = channels.first {
        await joinChannel(emergencyChannel)
      } else {
        showErrorMessage("No emergency channel available")
      }

    } catch {
      print("Error searching for emergency channel: \(error)")
      showErrorMessage("Unable to access emergency channel: \(error.localizedDescription)")
    }
  }

  // MARK: - State Management

  /// Transition to a new state
  private func transition(to newState: ParapenteAppState) {
    print("State: \(currentState) -> \(newState)")
    currentState = newState
  }

  /// Display an error message
  private func showErrorMessage(_ message: String) {
    errorMessage = message
    showError = true
  }

  /// Clear the error message
  func clearError() {
    showError = false
    errorMessage = ""
  }

  // MARK: - Cleanup

  private func cleanupServices() async {
    // Stop the transmission if active
    if let audioManager = audioManager {
      await audioManager.stopRecording()
    }

    // Leave the channel if connected
    if let pttChannelManager = pttChannelManager {
      try? await pttChannelManager.leaveCurrentChannel()
    }

    // Clean up references
    audioManager = nil
    pttChannelManager = nil
  }

  // MARK: - Notification Handlers

  @objc private func handleAuthenticationStateChanged() {
    Task {
      await checkAuthenticationState()
    }
  }

  @objc private func handleTokenWillExpire() {
    Task {
      await refreshAuthenticationToken()
    }
  }

  private func refreshAuthenticationToken() async {
    // TODO: Implement token renewal with Auth0
    // For now, redirect to authentication
    print("Token expired, authentication required")
    transition(to: .authentication)
  }

  // MARK: - Helper Methods

  private func getCurrentChannel(from pttManager: PTTChannelManager) async -> PTTChannel? {
    // Retrieve the current channel from the PTT manager
    return pttManager.currentChannel
  }
}

// MARK: - State Extensions

extension ParapenteStateManager {

  /// Retrieve the current PTT state
  func getCurrentPTTState() -> String? {
    guard let pttManager = pttChannelManager else { return nil }
    
    if pttManager.isTransmitting {
      return "transmitting"
    } else if pttManager.isJoined {
      return "connected"
    } else {
      return "disconnected"
    }
  }

  /// Check if a transmission can be started
  func canStartTransmission() -> Bool {
    return pttChannelManager != nil && audioManager != nil
  }

  /// Retrieve the current audio stats
  func getCurrentAudioStats() -> AudioStats? {
    return audioManager?.getAudioStats()
  }

  /// Check if the user has a specific permission
  func hasPermission(_ permission: String) -> Bool {
    return keychainManager.hasPermission(permission)
  }

  /// Retrieve the current network info
  func getNetworkInfo() -> NetworkInfo? {
    return networkService?.getNetworkInfo()
  }
}

// MARK: - Development Extensions

#if DEBUG
  extension ParapenteStateManager {

    /// Debug methods for development
    func debugPrintCurrentState() {
      print("=== State Manager Debug Info ===")
      print("Current State: \(currentState)")
      print("Network Service: \(networkService != nil ? "Available" : "Nil")")
      print("PTT Manager: \(pttChannelManager != nil ? "Available" : "Nil")")
      print("Audio Manager: \(audioManager != nil ? "Available" : "Nil")")
      print("Authentication Status: \(keychainManager.getAuthenticationStatus())")
      print("===============================")
    }

    /// Simulate an error to test error handling
    func debugSimulateError() {
      transition(
        to: .error(
          .networkError(
            NSError(
              domain: "DebugError", code: 999, userInfo: [NSLocalizedDescriptionKey: "Test error"]))
        ))
    }

    /// Simulate a successful authentication
    func debugSimulateSuccessfulAuth() {
      Task {
        await authenticateWithAuth0()
      }
    }

    /// Force logout for tests
    func debugForceLogout() {
      Task {
        await logout()
      }
    }
  }
#endif

// MARK: - Error Recovery

extension ParapenteStateManager {

  /// Attempt to recover from an error
  func recoverFromError() async {
    switch currentState {
    case .error(let error):
      print("Attempting error recovery: \(error)")

      switch error {
      case .authenticationFailed, .tokenExpired:
        // Authentication errors -> return to authentication
        transition(to: .authentication)

      case .networkError:
        // Network errors -> check connectivity and retry
        if let networkService = networkService, networkService.isConnected {
          await checkAuthenticationState()
        } else {
          showErrorMessage("Check your internet connection and try again")
        }

      case .channelNotFound, .insufficientPermissions:
        // Channel errors -> return to selection
        await loadAvailableChannels()

      case .transmissionFailed, .audioError:
        // Transmission errors -> cleanup and return to channel
        if let pttChannelManager = pttChannelManager,
          let currentChannel = await getCurrentChannel(from: pttChannelManager)
        {
          transition(to: .channelJoined(channel: currentChannel))
        } else {
          await loadAvailableChannels()
        }

      default:
        // Other errors -> return to authentication
        transition(to: .authentication)
      }

    default:
      print("No error to recover")
    }
  }
}

// MARK: - Background Task Management

extension ParapenteStateManager {

  /// Handle entering background
  func handleAppDidEnterBackground() {
    print("Application entered background")

    // Pause transmissions if necessary
    // The PTT framework will continue to run in the background
  }

  /// Handle returning to foreground
  func handleAppWillEnterForeground() {
    print("Application returning to foreground")

    Task {
      // Check authentication state
      await checkAuthenticationState()

      // Reload data if needed
      if case .authenticated = currentState {
        await loadAvailableChannels()
      }
    }
  }

  /// Go back to previous state
  func goBack() async {
    switch currentState {
    case .error, .channelSelection:
      do {
        let permissions = try keychainManager.getUserPermissions() ?? []
        transition(to: .authenticated(permissions: permissions))
      } catch {
        transition(to: .authenticated(permissions: []))
      }
    case .channelJoined, .activeTransmission:
      await leaveChannel()
      do {
        let permissions = try keychainManager.getUserPermissions() ?? []
        transition(to: .authenticated(permissions: permissions))
      } catch {
        transition(to: .authenticated(permissions: []))
      }
    default:
      transition(to: .launching)
    }
  }

  /// Retry current operation
  func retry() async {
    switch currentState {
    case .error:
      await checkAuthenticationState()
    default:
      break
    }
  }

  /// Leave current channel
  func leaveChannel() async {
    do {
      try await pttChannelManager?.leaveCurrentChannel()
      do {
        let permissions = try keychainManager.getUserPermissions() ?? []
        transition(to: .authenticated(permissions: permissions))
      } catch {
        transition(to: .authenticated(permissions: []))
      }
    } catch {
      transition(to: .error(.networkError(error)))
    }
  }
}
